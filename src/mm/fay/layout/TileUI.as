 package mm.fay.layout {	import flash.display.DisplayObject;	import flash.display.DisplayObjectContainer;		import mm.fay.util.FConst;	import mm.fay.vo.Insets;	import mm.fay.vo.IntGap;
	/**	 * The TileUI class extends the LayoutUI class and works in the same way,	 * but it handles the position of its children by aligning them vertically in the box.	 * 	 * @example	 * <listing version="3.0">	 * var tile:TileUI = TileUI.create(stage);	 * tile.setSize(400, 300)	 * 		.setBackgroundColor(0xFF0000)	 * 		.setBackgroundAlpha(0.2)	 * 		.setGap(new IntGap(5, 5))	 * 		.setPadding(new Insets(5, 5, 5, 5))	 * 		.setAlign(TileUI.ALIGN_BOTTOM_RIGHT)	 * 		.setDirection(TileUI.DIRECTION_HORIZONTAL);	 * 	 * for (var i:int=0; i&lt;16; ++i) {	 * 	var sprite:Sprite = new Sprite();	 * 	sprite.graphics.beginFill(0xFF0000, .5);	 * 	sprite.graphics.drawRect(0, 0, 100, 100);	 * 	tile.addChild(sprite);	 * }	 * 	 * tile.refresh();	 * </listing>	 * 	 * @author Andy Cai <huayicai@gmail.com>	 * 	 */		public class TileUI extends LayoutUI	{		public static const ALIGN_TOP_LEFT:String = FConst.ALIGN_TOP_LEFT;		public static const ALIGN_TOP_RIGHT:String = FConst.ALIGN_TOP_RIGHT;		public static const ALIGN_BOTTOM_LEFT:String = FConst.ALIGN_BOTTOM_LEFT;		public static const ALIGN_BOTTOM_RIGHT:String = FConst.ALIGN_BOTTOM_RIGHT;		public static const DIRECTION_HORIZONTAL:int = FConst.HORIZONTAL;		public static const DIRECTION_VERTICAL:int = FConst.VERTICAL;				protected const LEFT:int = FConst.LEFT;		protected const RIGHT:int = FConst.RIGHT;		protected const TOP:int = FConst.TOP;		protected const BOTTOM:int = FConst.BOTTOM;				protected var _childrenDirection:int;				/**		 * Create a TileUI instance		 * @param reference DisplayObjectContainer instance used to calculate the size and position of the layout instance		 */		public function TileUI(parent:DisplayObjectContainer = null)		{			super(parent);		}				public static function create(parent:DisplayObjectContainer = null):TileUI		{			return new TileUI(parent);		}				override protected function initialize():void		{			super.initialize();			_childrenPadding = new Insets();			_childrenGap = new IntGap();			_childrenAlign = ALIGN_TOP_LEFT;			_childrenDirection = DIRECTION_HORIZONTAL;			setPrivateAlignment();//			_element.addEventListener(EventUI.UPDATED, updatedHandler);		}				/*protected function updatedHandler(e:EventUI):void {			if (!_childrenEnable) return;			update();
		}*/				override protected function update():void		{			var startX:Number = 0;			var startY:Number = 0;			switch (_horizontalAlign) {				case LEFT:					startX = _childrenPadding.left;					break;				case RIGHT:					startX = _width - _childrenPadding.right;					break;			}			switch (_verticalAlign) {				case TOP:					startY = _childrenPadding.top;					break;				case BOTTOM:					startY = _height - _childrenPadding.bottom;					break;			}			var posX:Number = startX;			var posY:Number = startY;			var lastWidth:Number = 0;			var lastHeight:Number = 0;			var i:Number = 0;			var l:Number = numChildren;			for (i; i<l; ++i) {				var obj:DisplayObject = getChildAt(i);				if (_horizontalAlign == RIGHT && _childrenDirection == DIRECTION_HORIZONTAL) posX -= obj.width;				if (_verticalAlign == BOTTOM && _childrenDirection == DIRECTION_VERTICAL) posY -= obj.height;				if (_childrenDirection == DIRECTION_HORIZONTAL) {					if (_horizontalAlign == LEFT) {						if (posX + obj.width + _childrenPadding.right > _width) {							posX = startX;							if (_verticalAlign == TOP) posY += lastHeight + _childrenGap.vertical;							else posY -= lastHeight + _childrenGap.vertical;							lastHeight = 0;						}					}					else {						if (posX - _childrenPadding.left < 0) {							posX = startX - obj.width;							if (_verticalAlign == TOP) posY += lastHeight + _childrenGap.vertical;							else posY -= lastHeight + _childrenGap.vertical;							lastHeight = 0;						}					}				}				else {					if (_verticalAlign == TOP) {						if (posY + obj.height + _childrenPadding.bottom > _height) {							if (_horizontalAlign == LEFT) posX += lastWidth + _childrenGap.horizontal;							else posX -= lastWidth + _childrenGap.horizontal;							posY = startY;							lastWidth = 0;						}					}					else {						if (posY - _childrenPadding.top < 0) {							if (_horizontalAlign == LEFT) posX += lastWidth + _childrenGap.horizontal;							else posX -= lastWidth + _childrenGap.horizontal;							posY = startY - obj.height;							lastWidth = 0;						}					}				}				obj.x = (_horizontalAlign == RIGHT && _childrenDirection == DIRECTION_VERTICAL) ? posX-obj.width : posX; 				obj.y = (_verticalAlign == BOTTOM && _childrenDirection == DIRECTION_HORIZONTAL) ? posY-obj.height : posY; 				if (_childrenDirection == DIRECTION_HORIZONTAL) {					if (_horizontalAlign == LEFT) posX = obj.x + obj.width + _childrenGap.horizontal;					else posX = obj.x - _childrenGap.horizontal;				}				else {					if (_verticalAlign == TOP) posY = obj.y + obj.height + _childrenGap.vertical;					else posY = obj.y - _childrenGap.vertical;				}				if (obj.width > lastWidth) lastWidth = obj.width;				if (obj.height > lastHeight) lastHeight = obj.height;			}						super.update();		}						///////////////////////////////////		// public methods		///////////////////////////////////		override public function dispose():void		{			// dispose objects, graphics and events listeners			try {//				if (_element != null) _element.removeEventListener(EventUI.UPDATED, updatedHandler);				_childrenPadding = null;				_childrenGap = null;				super.dispose();			} catch(e:Error) {				trace("Error in", this, "(dispose method):", e.message);			}		}				/**		 * Property to set the start position of the alignment of the DisplayObject children in the layout. 		 * The value can be TileUI.ALIGN_TOP_LEFT, TileUI.ALIGN_TOP_RIGHT, TileUI.ALIGN_BOTTOM_LEFT and TileUI.ALIGN_BOTTOM_RIGHT.		 */		override public function setAlign(value:String):LayoutUI		{			if (value != ALIGN_TOP_LEFT &&				value != ALIGN_TOP_RIGHT &&				value != ALIGN_BOTTOM_LEFT &&				value != ALIGN_BOTTOM_RIGHT) {				throw new Error("Error in " + this + " (" + name + "): the align property must be, for example: TileUI.ALIGN_TOP_LEFT");			}			_childrenAlign = value;			setPrivateAlignment();			return this;		}				/**		 * Property to set the direction of the alignment of the DisplayObject children in the layout. 		 * The value can be TileUI.ALIGN_TOP_LEFT, TileUI.ALIGN_TOP_RIGHT, TileUI.ALIGN_BOTTOM_LEFT and TileUI.ALIGN_BOTTOM_RIGHT.		 */		public function getDirection():int		{			return _childrenDirection;		}				public function setDirection(value:int):TileUI		{			if (value != DIRECTION_HORIZONTAL && value != DIRECTION_VERTICAL) {				throw new Error("Error in " + this + " (" + name + "): the align property must be DIRECTION_HORIZONTAL or DIRECTION_VERTICAL");			}			_childrenDirection = value;			return this;		}	}}